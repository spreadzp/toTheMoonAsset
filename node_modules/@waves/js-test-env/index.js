"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const wt = tslib_1.__importStar(require("@waves/waves-transactions"));
const ride_js_1 = require("@waves/ride-js");
const chai_1 = tslib_1.__importDefault(require("chai"));
const chai_as_promised_1 = tslib_1.__importDefault(require("chai-as-promised"));
chai_1.default.use(chai_as_promised_1.default);
function addEnvFunctionsToGlobal(global, options) {
    function withDefaults(options = {}) {
        return {
            timeout: options.timeout || global.env.timeout || 20000,
            apiBase: options.apiBase || global.env.API_BASE
        };
    }
    function currentAddress() {
        return wt.libs.crypto.address(global.env.SEED, global.env.CHAIN_ID);
    }
    function injectEnv(f) {
        return (po, seed) => f(Object.assign({ chainId: global.env.CHAIN_ID, additionalFee: seed === undefined && global.env.isScripted ? 400000 : undefined }, po), seed === null ? null : seed || global.env.SEED);
    }
    global.wavesCrypto = wt.libs.crypto;
    global.chai = chai_1.default;
    global.expect = chai_1.default.expect;
    global.alias = injectEnv(wt.alias);
    global.burn = injectEnv(wt.burn);
    global.cancelLease = injectEnv(wt.cancelLease);
    global.cancelOrder = injectEnv(wt.cancelOrder);
    global.data = injectEnv(wt.data);
    global.issue = injectEnv(wt.issue);
    global.reissue = injectEnv(wt.reissue);
    global.lease = injectEnv(wt.lease);
    global.massTransfer = injectEnv(wt.massTransfer);
    global.order = injectEnv(wt.order);
    global.transfer = injectEnv(wt.transfer);
    global.setScript = injectEnv(wt.setScript);
    global.setAssetScript = injectEnv(wt.setAssetScript);
    global.invokeScript = injectEnv(wt.invokeScript);
    global.sponsorship = injectEnv(wt.sponsorship);
    global.signTx = injectEnv(wt.signTx);
    global.waitForTx = async (txId, options) => wt.nodeInteraction.waitForTx(txId, withDefaults(options));
    global.waitForTxWithNConfirmations = async (txId, confirmations, options) => wt.nodeInteraction.waitForTxWithNConfirmations(txId, confirmations, withDefaults(options));
    global.waitNBlocks = (blocksCount, options) => wt.nodeInteraction.waitNBlocks(blocksCount, withDefaults(options));
    global.currentHeight = (apiBase) => wt.nodeInteraction.currentHeight(apiBase || global.env.API_BASE);
    global.waitForHeight = (target, options) => wt.nodeInteraction.waitForHeight(target, withDefaults(options));
    global.balance = (address, apiBase) => wt.nodeInteraction.balance(address || currentAddress(), apiBase || global.env.API_BASE);
    global.assetBalance = (assetId, address, apiBase) => wt.nodeInteraction.assetBalance(assetId, address || currentAddress(), apiBase || global.env.API_BASE);
    global.balanceDetails = (address, apiBase) => wt.nodeInteraction.balanceDetails(address || currentAddress(), apiBase || global.env.API_BASE);
    global.accountData = (address, apiBase) => wt.nodeInteraction.accountData(address || currentAddress(), apiBase || global.env.API_BASE);
    global.accountDataByKey = (key, address, apiBase) => wt.nodeInteraction.accountDataByKey(key, address || currentAddress(), apiBase || global.env.API_BASE);
    global.stateChanges = (invokeScriptTxId, apiBase) => wt.nodeInteraction.stateChanges(invokeScriptTxId, apiBase || global.env.API_BASE);
    global.broadcast = (tx, apiBase) => options && options.broadcastWrapper
        ? options.broadcastWrapper(wt.nodeInteraction.broadcast)(tx, apiBase || global.env.API_BASE)
        : wt.nodeInteraction.broadcast(tx, apiBase || global.env.API_BASE);
    global.file = (name) => {
        if (typeof global.env.file !== 'function') {
            throw new Error('File content API is not available. Please provide it to the console');
        }
        return global.env.file(name);
    };
    global.contract = () => global.env.file();
    global.keyPair = (seed) => wt.libs.crypto.keyPair(seed || global.env.SEED);
    global.publicKey = (seed) => wt.libs.crypto.keyPair(seed || global.env.SEED).publicKey;
    global.privateKey = (seed) => wt.libs.crypto.keyPair(seed || global.env.SEED).privateKey;
    global.address = (seed, chainId) => wt.libs.crypto.address(seed || global.env.SEED, chainId || global.env.CHAIN_ID);
    global.compile = (code) => {
        const resultOrError = ride_js_1.compile(code);
        if ('error' in resultOrError)
            throw new Error(resultOrError.error);
        return resultOrError.result.base64;
    };
    global.signBytes = (bytes, seed) => wt.libs.crypto.signBytes(bytes, seed || global.env.SEED);
    global.setupAccounts = async (balances, options) => {
        if (!global.accounts)
            global.accounts = {};
        const getNonce = () => [].map.call(wt.libs.crypto.randomBytes(4), (n) => n.toString(16))
            .join('');
        const nonce = (options && options.nonce) || getNonce();
        const masterSeed = (options && options.masterSeed) || global.env.SEED;
        global.console.log(`Generating accounts with nonce: ${nonce}`);
        const transfers = [];
        Object.entries(balances).forEach(([name, balance]) => {
            const seed = name + '#' + nonce;
            const addr = wt.libs.crypto.address(seed, global.env.CHAIN_ID);
            global.accounts[name] = seed;
            global.console.log(`Account generated: ${seed} - ${addr}`);
            transfers.push({
                recipient: addr,
                amount: balance
            });
        });
        const mtt = global.massTransfer({ transfers }, masterSeed);
        await global.broadcast(mtt);
        await global.waitForTx(mtt.id);
        global.console.log(`Accounts successfully funded`);
        return Object.assign({}, global.env.accounts);
    };
}
exports.addEnvFunctionsToGlobal = addEnvFunctionsToGlobal;
