"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CryptoJS = require("crypto-js");
var base_xx_1 = require("./base-xx");
var string_bytes_1 = require("./string-bytes");
var isString = function (val) { return typeof val === 'string' || val instanceof String; };
var isUint8Array = function (val) { return val instanceof Uint8Array; };
var isTRawStringInDiscriminator = function (_) { return false; };
exports._fromIn = function (inValue) {
    if (isString(inValue))
        return base_xx_1.base58Decode(inValue);
    if (isUint8Array(inValue))
        return inValue;
    return Uint8Array.from(inValue);
};
exports._fromRawIn = function (inValue) {
    if (isTRawStringInDiscriminator(inValue))
        throw new Error('');
    if (isString(inValue))
        return string_bytes_1.stringToBytes(inValue);
    if (isUint8Array(inValue))
        return inValue;
    return Uint8Array.from(inValue);
};
exports._toWords = function (arr) {
    var len = arr.length;
    var words = [];
    for (var i = 0; i < len; i++) {
        words[i >>> 2] |= (arr[i] & 0xff) << (24 - (i % 4) * 8);
    }
    return CryptoJS.lib.WordArray.create(words, len);
};
exports._fromWords = function (inValue) {
    var words = inValue.words;
    var sigBytes = inValue.sigBytes;
    var u8 = new Uint8Array(sigBytes);
    for (var i = 0; i < sigBytes; i++) {
        var byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
        u8[i] = byte;
    }
    return u8;
};
//# sourceMappingURL=param.js.map