export { seedWordsList } from './crypto/seed-words-list';
export { ChaidId } from './extensions/chain-id';
export { Seed } from './extensions/seed';
export { isPrivateKey, isPublicKey } from './crypto/util';
export { crypto } from './crypto/crypto';
export * from './crypto/interface';
export declare const signBytes: (seedOrPrivateKey: string | number[] | Uint8Array | import("./crypto/interface").INonceSeed | import("./crypto/interface").TRawStringInDiscriminator | import("./crypto/interface").TPrivateKey<import("./crypto/interface").TBinaryIn>, bytes: import("./crypto/interface").TBinaryIn, random?: string | number[] | Uint8Array | undefined) => string, keyPair: (seed: import("./crypto/interface").TSeed) => import("./crypto/interface").TKeyPair<string>, publicKey: (seed: import("./crypto/interface").TSeed) => string, privateKey: (seed: import("./crypto/interface").TSeed) => string, address: (seedOrPublicKey: string | number[] | Uint8Array | import("./crypto/interface").INonceSeed | import("./crypto/interface").TRawStringInDiscriminator | import("./crypto/interface").TPublicKey<import("./crypto/interface").TBinaryIn>, chainId?: string | number | undefined) => string, blake2b: (input: import("./crypto/interface").TBinaryIn) => Uint8Array, keccak: (input: import("./crypto/interface").TBinaryIn) => Uint8Array, sha256: (input: import("./crypto/interface").TBinaryIn) => Uint8Array, sharedKey: (privateKeyFrom: import("./crypto/interface").TBinaryIn, publicKeyTo: import("./crypto/interface").TBinaryIn, prefix: import("./crypto/interface").TRawStringIn) => string, seedWithNonce: (seed: import("./crypto/interface").TSeed, nonce: number) => import("./crypto/interface").INonceSeed, base64Encode: (input: import("./crypto/interface").TBinaryIn) => string, base64Decode: (input: string) => Uint8Array, base58Encode: (input: import("./crypto/interface").TBinaryIn) => string, base58Decode: (input: string) => Uint8Array, base16Encode: (input: import("./crypto/interface").TBinaryIn) => string, base16Decode: (input: string) => Uint8Array, stringToBytes: (input: string) => Uint8Array, bytesToString: (input: import("./crypto/interface").TBinaryIn) => string, randomSeed: (wordsCount?: number | undefined) => string, randomBytes: (size: number) => Uint8Array, verifySignature: (publicKey: import("./crypto/interface").TBinaryIn, bytes: import("./crypto/interface").TBinaryIn, signature: import("./crypto/interface").TBinaryIn) => boolean, verifyPublicKey: (publicKey: import("./crypto/interface").TBinaryIn) => boolean, verifyAddress: (address: import("./crypto/interface").TBinaryIn, optional?: {
    chainId?: string | number | undefined;
    publicKey?: string | number[] | Uint8Array | undefined;
} | undefined) => boolean, messageDecrypt: (sharedKey: import("./crypto/interface").TBinaryIn, encryptedMessage: import("./crypto/interface").TBinaryIn) => string, messageEncrypt: (sharedKey: import("./crypto/interface").TBinaryIn, message: import("./crypto/interface").TRawStringIn) => Uint8Array, aesDecrypt: (encryptedData: import("./crypto/interface").TBinaryIn, secret: import("./crypto/interface").TBinaryIn, mode?: "CBC" | "CFB" | "CTR" | "OFB" | "ECB" | undefined, iv?: string | number[] | Uint8Array | undefined) => Uint8Array, aesEncrypt: (data: import("./crypto/interface").TRawStringIn, secret: import("./crypto/interface").TBinaryIn, mode?: "CBC" | "CFB" | "CTR" | "OFB" | "ECB" | undefined, iv?: string | number[] | Uint8Array | undefined) => Uint8Array, split: (binary: import("./crypto/interface").TBinaryIn, ...sizes: number[]) => Uint8Array[], concat: (...binaries: import("./crypto/interface").TBinaryIn[]) => Uint8Array;
