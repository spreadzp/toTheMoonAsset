export declare const PUBLIC_KEY_LENGTH = 32;
export declare const PRIVATE_KEY_LENGTH = 32;
export declare const SIGNATURE_LENGTH = 64;
export declare const ADDRESS_LENGTH = 26;
export declare const MAIN_NET_CHAIN_ID = 87;
export declare const TEST_NET_CHAIN_ID = 84;
export interface INonceSeed {
    seed: TBytes;
    nonce?: number;
}
export declare type AESMode = 'CBC' | 'CFB' | 'CTR' | 'OFB' | 'ECB';
export declare type TBytes = Uint8Array;
export declare type TBase64 = string;
export declare type TBase58 = string;
export declare type TBase16 = string;
export declare type TChainId = string | number;
export declare type TBinaryIn = TBytes | TBase58 | number[];
export declare type TRawStringInDiscriminator = {
    TRawStringIn: null;
};
export declare type TRawStringIn = TBytes | string | number[] | TRawStringInDiscriminator;
export declare type TBinaryOut = TBytes | TBase58;
export declare type TPublicKey<T extends TBinaryIn = TBase58> = {
    publicKey: T;
};
export declare type TPrivateKey<T extends TBinaryIn = TBase58> = {
    privateKey: T;
};
export declare type TKeyPair<T extends TBinaryIn = TBase58> = TPublicKey<T> & TPrivateKey<T>;
export declare type TSeed = TRawStringIn | INonceSeed;
export interface ISeedRelated<TDesiredOut extends TBinaryOut = TBase58> {
    seedWithNonce: (seed: TSeed, nonce: number) => INonceSeed;
    keyPair: (seed: TSeed) => TKeyPair<TDesiredOut>;
    publicKey: (seed: TSeed) => TDesiredOut;
    privateKey: (seed: TSeed) => TDesiredOut;
    address: (seedOrPublicKey: TSeed | TPublicKey<TBinaryIn>, chainId?: TChainId) => TDesiredOut;
    signBytes: (seedOrPrivateKey: TSeed | TPrivateKey<TBinaryIn>, bytes: TBinaryIn, random?: TBinaryIn) => TDesiredOut;
}
export interface ISeedEmbeded<TDesiredOut extends TBinaryOut = TBase58> {
    seedWithNonce: (nonce: number) => INonceSeed;
    keyPair: () => TKeyPair<TDesiredOut>;
    publicKey: () => TDesiredOut;
    privateKey: () => TDesiredOut;
    address: (chainId?: TChainId) => TDesiredOut;
    signBytes: (bytes: TBinaryIn, random?: TBinaryIn) => TDesiredOut;
}
export interface IWavesCrypto<TDesiredOut extends TBinaryOut = TBase58> {
    blake2b: (input: TBinaryIn) => TBytes;
    keccak: (input: TBinaryIn) => TBytes;
    sha256: (input: TBinaryIn) => TBytes;
    base64Encode: (input: TBinaryIn) => TBase64;
    base64Decode: (input: TBase64) => TBytes;
    base58Encode: (input: TBinaryIn) => TBase58;
    base58Decode: (input: TBase58) => TBytes;
    base16Encode: (input: TBinaryIn) => TBase16;
    base16Decode: (input: TBase16) => TBytes;
    stringToBytes: (input: string) => TBytes;
    bytesToString: (input: TBinaryIn) => string;
    split: (binary: TBinaryIn, ...sizes: number[]) => TBytes[];
    concat: (...binaries: TBinaryIn[]) => TBytes;
    randomBytes: (size: number) => TBytes;
    randomSeed: (wordsCount?: number) => string;
    verifySignature: (publicKey: TBinaryIn, bytes: TBinaryIn, signature: TBinaryIn) => boolean;
    verifyPublicKey: (publicKey: TBinaryIn) => boolean;
    verifyAddress: (address: TBinaryIn, optional?: {
        chainId?: TChainId;
        publicKey?: TBinaryIn;
    }) => boolean;
    sharedKey: (privateKeyFrom: TBinaryIn, publicKeyTo: TBinaryIn, prefix: TRawStringIn) => TDesiredOut;
    messageDecrypt: (sharedKey: TBinaryIn, encryptedMessage: TBinaryIn) => string;
    messageEncrypt: (sharedKey: TBinaryIn, message: TRawStringIn) => TBytes;
    aesEncrypt: (data: TRawStringIn, secret: TBinaryIn, mode?: AESMode, iv?: TBinaryIn) => TBytes;
    aesDecrypt: (encryptedData: TBinaryIn, secret: TBinaryIn, mode?: AESMode, iv?: TBinaryIn) => TBytes;
}
