"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = require("crypto");
var param_1 = require("../conversions/param");
var hashing_1 = require("./hashing");
var concat_split_1 = require("./concat-split");
var axlsign_1 = require("../libs/axlsign");
var base_xx_1 = require("../conversions/base-xx");
var CryptoJS = require("crypto-js");
var string_bytes_1 = require("../conversions/string-bytes");
var aesModeMap = {
    'CBC': CryptoJS.mode.CBC,
    'CFB': CryptoJS.mode.CFB,
    'CTR': CryptoJS.mode.CTR,
    'OFB': CryptoJS.mode.OFB,
    'ECB': CryptoJS.mode.ECB,
};
exports.aesEncrypt = function (data, secret, mode, iv) {
    if (mode === void 0) { mode = 'CBC'; }
    return base_xx_1.base64Decode(CryptoJS.AES.encrypt(param_1._toWords(param_1._fromRawIn(data)), string_bytes_1.bytesToString(param_1._fromRawIn(secret)), {
        iv: iv ? param_1._toWords(param_1._fromIn(iv)) : undefined,
        mode: aesModeMap[mode],
    })
        .toString());
};
exports.aesDecrypt = function (encryptedData, secret, mode, iv) {
    if (mode === void 0) { mode = 'CBC'; }
    return param_1._fromWords(CryptoJS.AES.decrypt(base_xx_1.base64Encode(encryptedData), string_bytes_1.bytesToString(param_1._fromRawIn(secret)), {
        iv: iv ? param_1._toWords(param_1._fromIn(iv)) : undefined,
        mode: aesModeMap[mode],
    }));
};
exports.messageEncrypt = function (sharedKey, message) {
    var CEK = crypto_1.randomBytes(32);
    var IV = crypto_1.randomBytes(16);
    var m = param_1._fromRawIn(message);
    var Cc = exports.aesEncrypt(m, CEK, 'CTR', IV);
    var Ccek = exports.aesEncrypt(CEK, sharedKey, 'ECB');
    var Mhmac = hashing_1.hmacSHA256(m, CEK);
    var CEKhmac = hashing_1.hmacSHA256(concat_split_1.concat(CEK, IV), sharedKey);
    var packageBytes = concat_split_1.concat(Ccek, CEKhmac, Mhmac, IV, Cc);
    return packageBytes;
};
exports.messageDecrypt = function (sharedKey, encryptedMessage) {
    var _a = __read(concat_split_1.split(encryptedMessage, 64, 32, 32, 16), 5), Ccek = _a[0], _CEKhmac = _a[1], _Mhmac = _a[2], iv = _a[3], Cc = _a[4];
    var CEK = exports.aesDecrypt(Ccek, sharedKey, 'ECB');
    var CEKhmac = param_1._fromIn(hashing_1.hmacSHA256(concat_split_1.concat(CEK, iv), param_1._fromIn(sharedKey)));
    var isValidKey = CEKhmac.every(function (v, i) { return v === _CEKhmac[i]; });
    if (!isValidKey)
        throw new Error('Invalid key');
    var M = exports.aesDecrypt(Cc, CEK, 'CTR', iv);
    var Mhmac = param_1._fromIn(hashing_1.hmacSHA256(M, CEK));
    var isValidMessage = Mhmac.every(function (v, i) { return v === _Mhmac[i]; });
    if (!isValidMessage)
        throw new Error('Invalid message');
    return String.fromCharCode.apply(null, Array.from(M));
};
exports.sharedKey = function (privateKeyFrom, publicKeyTo, prefix) {
    var sharedKey = axlsign_1.default.sharedKey(param_1._fromIn(privateKeyFrom), param_1._fromIn(publicKeyTo));
    var prefixHash = hashing_1.sha256(param_1._fromRawIn(prefix));
    return hashing_1.hmacSHA256(sharedKey, prefixHash);
};
//# sourceMappingURL=encryption.js.map