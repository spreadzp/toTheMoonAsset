"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const nconf_1 = require("nconf");
const bip39_1 = require("bip39");
const waves_transactions_1 = require("@waves/waves-transactions");
exports.systemConfig = {
    ride_directory: 'ride',
    test_directory: 'test',
    envs: {
        custom: {
            API_BASE: 'http://localhost:6869/',
            CHAIN_ID: 'R',
            SEED: 'waves private node seed with waves tokens',
            timeout: 60000
        },
        testnet: {
            API_BASE: 'https://testnodes.wavesnodes.com/',
            CHAIN_ID: 'T',
            SEED: 'testnet seed placeholder',
            timeout: 60000
        }
    },
    defaultEnv: 'custom',
    mocha: {
        timeout: 60000
    }
};
class ConfigService {
    constructor() {
        this.getConfigPath = (configName) => {
            const workingDirPath = process.cwd();
            const CONFIG_NAME_PATH_MAP = {
                globalConfig: `${this.oclifConfig && this.oclifConfig.root}/lib/surfboard.config.json`,
                localConfig: `${workingDirPath}/surfboard.config.json`
            };
            return CONFIG_NAME_PATH_MAP[configName];
        };
        this.updateConfig = async (configName, key, value) => {
            const nconf = new nconf_1.Provider();
            const configFilePath = this.getConfigPath(configName);
            nconf.file(configName, { file: configFilePath });
            if (nconf.get(key)) {
                nconf.set(key, value);
                nconf.save('');
                return `${configName} was updated successfully`;
            }
            else {
                throw new Error(`Option ${key} is not found in config file`);
            }
        };
        this.createLocalConfigFile = () => {
            const localConfigFilePath = this.getConfigPath('localConfig');
            const config = this.generateConfig();
            const seed = config.envs.testnet.SEED;
            const addr = waves_transactions_1.libs.crypto.address(seed, 'T');
            console.log(`❗️Generated new local config\nTestnet seed="${seed}"\nTestnet address="${addr}"❗`);
            fs.writeFileSync(localConfigFilePath, JSON.stringify(config, null, 4));
        };
    }
    initialize(oclifConfig) {
        this.oclifConfig = oclifConfig;
        const globalConfPath = this.getConfigPath('globalConfig');
        if (!fs.existsSync(globalConfPath)) {
            fs.writeFileSync(globalConfPath, JSON.stringify(this.generateConfig(), null, 4));
        }
    }
    generateConfig() {
        const testnetSeed = bip39_1.generateMnemonic();
        const config = JSON.parse(JSON.stringify(exports.systemConfig));
        config.envs.testnet.SEED = testnetSeed;
        return config;
    }
    getConfig(configName) {
        const nconf = new nconf_1.Provider();
        const configPath = this.getConfigPath(configName);
        if (fs.existsSync(configPath)) {
            nconf.defaults({ type: 'file', file: configPath });
            return nconf;
        }
        else {
            return { error: `Failed to get ${configName} at ${configPath}` };
        }
    }
    get config() {
        const nconf = new nconf_1.Provider();
        const globalConfPath = this.getConfigPath('globalConfig');
        const localConfPath = this.getConfigPath('localConfig');
        if (fs.existsSync(globalConfPath)) {
            nconf.defaults({ type: 'file', file: globalConfPath }); //global config
        }
        else {
            nconf.defaults({ type: 'literal', store: exports.systemConfig }); //system config
        }
        if (fs.existsSync(localConfPath)) {
            nconf.defaults({ type: 'file', file: localConfPath }); //local config
        }
        return nconf;
    }
}
const configService = new Proxy(new ConfigService(), {
    get: (target, p) => {
        if (p !== 'initialize' && !target.oclifConfig) {
            throw new Error('Config service has not been initialized');
        }
        return target[p];
    }
});
exports.default = configService;
//# sourceMappingURL=index.js.map