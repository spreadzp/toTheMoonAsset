"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const mocha_1 = tslib_1.__importDefault(require("mocha"));
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const url_1 = tslib_1.__importDefault(require("url"));
const waves_transactions_1 = require("@waves/waves-transactions");
const config_1 = tslib_1.__importDefault(require("../config"));
const testEnv_1 = require("./testEnv");
class TestRunner {
    constructor(mochaOptions) {
        this.getContractFile = (fileNameOrPath) => {
            const pathIfFileName = path.join(process.cwd(), config_1.default.config.get('ride_directory'), fileNameOrPath);
            const pathIfPath = path.resolve(process.cwd(), fileNameOrPath);
            if (fs.existsSync(pathIfPath)) {
                return fs.readFileSync(pathIfPath, 'utf-8');
            }
            else if (fs.existsSync(pathIfFileName)) {
                return fs.readFileSync(pathIfFileName, 'utf8');
            }
            throw new Error(`File "${fileNameOrPath}" not found`);
        };
        this.mocha = new mocha_1.default(mochaOptions);
    }
    static getInstance() {
        if (!TestRunner.instance) {
            const mochaOptions = config_1.default.config.get('mocha');
            TestRunner.instance = new TestRunner(mochaOptions);
        }
        return TestRunner.instance;
    }
    addFile(path) {
        this.mocha.addFile(path);
    }
    async run({ envName, verbose }) {
        const config = config_1.default.config;
        if (envName == null) {
            envName = config.get('defaultEnv');
        }
        let env = config.get('envs:' + envName);
        if (env == null)
            cli_ux_1.default.error(`Failed to get environment "${envName}"\n Check your if your config contains it`);
        await this.checkNode(url_1.default.parse(env.API_BASE).href);
        const envAddress = waves_transactions_1.libs.crypto.address(env.SEED, env.CHAIN_ID);
        cli_ux_1.default.log(`Starting test with "${envName}" environment\nRoot address: ${envAddress}`);
        env = Object.assign({ file: this.getContractFile }, env);
        testEnv_1.injectTestEnvironment(global, { verbose, env });
        let failed = true;
        try {
            const result = this.mocha.run();
            // wait for test to finish running
            await new Promise(resolve => {
                if (result.stats && result.stats.end !== undefined)
                    resolve();
                result.once('end', resolve);
            });
            if (result.stats && result.stats.failures === 0) {
                failed = false;
            }
        }
        catch (e) {
            console.error(e);
        }
        finally {
            if (failed)
                process.exit(2);
        }
    }
    async checkNode(nodeUrl) {
        try {
            await axios_1.default.get('node/version', { baseURL: nodeUrl });
        }
        catch (e) {
            cli_ux_1.default.error(`Failed to access node on "${nodeUrl}"\n` +
                'Make sure env.API_BASE is correct\n' +
                'In case of using local node, make sure it is up and running!');
        }
    }
}
exports.TestRunner = TestRunner;
exports.default = TestRunner;
//# sourceMappingURL=index.js.map